<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Mbsky by wangfakang</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Mbsky</h1>
        <p class="header">nginx惊群</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky0/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/wangfakang/sky0/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/wangfakang/sky0">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/wangfakang">wangfakang</a></p>


      </header>
      <section>
        <p><code>nginx惊群问题简单分析：
</code></p>

<h1>
<a id="内容" class="anchor" href="#%E5%86%85%E5%AE%B9" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容：</h1>

<h2>
<a id="一惊群含义" class="anchor" href="#%E4%B8%80%E6%83%8A%E7%BE%A4%E5%90%AB%E4%B9%89" aria-hidden="true"><span class="octicon octicon-link"></span></a>一：惊群含义</h2>

<h2>
<a id="二nginx如何解决惊群" class="anchor" href="#%E4%BA%8Cnginx%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>二：nginx如何解决惊群</h2>

<h2>
<a id="三何时释放该锁" class="anchor" href="#%E4%B8%89%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE%E8%AF%A5%E9%94%81" aria-hidden="true"><span class="octicon octicon-link"></span></a>三：何时释放该锁</h2>

<h2>
<a id="四相应代码解析" class="anchor" href="#%E5%9B%9B%E7%9B%B8%E5%BA%94%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>四：相应代码解析</h2>

<h3>
<a id="一惊群含义-1" class="anchor" href="#%E4%B8%80%E6%83%8A%E7%BE%A4%E5%90%AB%E4%B9%89-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>一.惊群含义:</h3>

<p>昨天所说的惊群含义是指:   </p>

<ul>
<li>当一个请求来到的时候,多个work进程的epoll注册监听端口都发生了可读事件,此时多个work进程都会去执行accept系统调用但最
终只有一个work进程accept执行成功,造成了没有必要的上下文切换(这里的accept操作可以更深层次的"唤醒",此处所说的"唤醒"不是
说开始work进程都挂起的,然后把其唤醒,其实work进程几乎一直都是工作的如:处理一些之前已经建立好的一些网络事件).</li>
</ul>

<h3>
<a id="二nginx是解决惊群" class="anchor" href="#%E4%BA%8Cnginx%E6%98%AF%E8%A7%A3%E5%86%B3%E6%83%8A%E7%BE%A4" aria-hidden="true"><span class="octicon octicon-link"></span></a>二.nginx是解决惊群</h3>

<ul>
<li>增加了一个"accept_mutex"锁,当其当前work进程抢到锁了才会去把监听端口的文件描述符加载到自己的epoll中,其他没有抢到的w
ork进程会把之前所注册的相应端口的事件全部删除,此时会处理之前建立连接上的一些网络事件.即"在同一个时刻只会有一个work进程
会在epoll中注册监听端口的描述符,每一个work进程都共享该监听端口描述符".</li>
</ul>

<h3>
<a id="三获得的锁何时释放" class="anchor" href="#%E4%B8%89%E8%8E%B7%E5%BE%97%E7%9A%84%E9%94%81%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE" aria-hidden="true"><span class="octicon octicon-link"></span></a>三.获得的锁何时释放</h3>

<ul>
<li>抢到的锁何时释放,nginx是这样做的:使用了两个事件队列(ngx_posted_accept_events:可以理解为存放新建连接的事件,然后ngx_p
osted_events:存放处理建立连接的事件),其实释放锁的地方就是:把新来的连接取出已经完成了三次握手了(此时把该事件放到ngx_pos
ted_events)然后就会释放锁.<br>
</li>
<li>锁释放了此时在处理ngx_posted_events(已经建立好连接的相关网络事件)上的事件,这样就可以让下次新的连接可以得到更快的处理,后面再来新的连接的时候继续按照前面的处理方式处理.<br>
</li>
<li>注意:nginx的监听是采用的epoll的LT模式,有这样一个场景,就是当在处理新建连接中此时如果有一个新的请求又来了,由于监听
用epoll默认的模式(EPOLLT),所以新的请求被阻塞到监听套接口上,此时等释放了锁后其它进程取到了锁后会处理监听套接口上的连接.</li>
</ul>

<h3>
<a id="四代码解析" class="anchor" href="#%E5%9B%9B%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>四.代码解析</h3>

<div class="highlight highlight-c"><pre>    <span class="pl-k">void</span>
    <span class="pl-en">ngx_process_events_and_timers</span>(<span class="pl-c1">ngx_cycle_t</span> *cycle)
    {
    <span class="pl-c1">ngx_uint_t</span>  flags;
    <span class="pl-c1">ngx_msec_t</span>  timer, delta;

    <span class="pl-k">if</span> (ngx_timer_resolution) {
        timer = NGX_TIMER_INFINITE;
        flags = <span class="pl-c1">0</span>;

    } <span class="pl-k">else</span> {
        timer = <span class="pl-c1">ngx_event_find_timer</span>();
        flags = NGX_UPDATE_TIME;

    #<span class="pl-k">if</span> (NGX_THREADS)

        <span class="pl-k">if</span> (timer == NGX_TIMER_INFINITE || timer &gt; <span class="pl-c1">500</span>) {
            timer = <span class="pl-c1">500</span>;
        }

    #<span class="pl-k">endif</span>
    }

    <span class="pl-k">if</span> (ngx_use_accept_mutex) {
        <span class="pl-c">//表示当前进程的负载超过了最大连接数的7/8</span>
        <span class="pl-k">if</span> (ngx_accept_disabled &gt; <span class="pl-c1">0</span>) {
            ngx_accept_disabled--;

        } <span class="pl-k">else</span> {
            <span class="pl-k">if</span> (<span class="pl-c1">ngx_trylock_accept_mutex</span>(cycle) == NGX_ERROR) {
                <span class="pl-k">return</span>;
            }

            <span class="pl-k">if</span> (ngx_accept_mutex_held) {
                flags |= NGX_POST_EVENTS;

            } <span class="pl-k">else</span> {<span class="pl-c">// 不让其平凡的获取到锁   </span>
                <span class="pl-k">if</span> (timer == NGX_TIMER_INFINITE
                    || timer &gt; ngx_accept_mutex_delay)
                {
                    timer = ngx_accept_mutex_delay;
                }
            }
        }
    }

    delta = ngx_current_msec;

    (<span class="pl-k">void</span>) <span class="pl-c1">ngx_process_events</span>(cycle, timer, flags);

    delta = ngx_current_msec - delta;

    <span class="pl-c1">ngx_log_debug1</span>(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                   <span class="pl-s"><span class="pl-pds">"</span>timer delta: <span class="pl-ii">%</span>M<span class="pl-pds">"</span></span>, delta);
    <span class="pl-c">//处理新来的事件建立连接</span>
    <span class="pl-k">if</span> (ngx_posted_accept_events) {
        <span class="pl-c1">ngx_event_process_posted</span>(cycle, &amp;ngx_posted_accept_events);
    }
    <span class="pl-c">//处理完了就把其锁给释放了,让其新的连接可以被其尽快处理</span>
    <span class="pl-k">if</span> (ngx_accept_mutex_held) {
        <span class="pl-c1">ngx_shmtx_unlock</span>(&amp;ngx_accept_mutex);
    }

    <span class="pl-k">if</span> (delta) {
        <span class="pl-c1">ngx_event_expire_timers</span>();
    }

    <span class="pl-c1">ngx_log_debug1</span>(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                   <span class="pl-s"><span class="pl-pds">"</span>posted events <span class="pl-c1">%p</span><span class="pl-pds">"</span></span>, ngx_posted_events);
    <span class="pl-c">//锁释放了才处理已经建立好的事件(已经完成了三次握手的事件)</span>
    <span class="pl-k">if</span> (ngx_posted_events) {
        <span class="pl-k">if</span> (ngx_threaded) {
            <span class="pl-c1">ngx_wakeup_worker_thread</span>(cycle);

        } <span class="pl-k">else</span> {
            <span class="pl-c1">ngx_event_process_posted</span>(cycle, &amp;ngx_posted_events);
        }
    }
    }</pre></div>

<hr>

<div class="highlight highlight-c"><pre>  <span class="pl-c1">ngx_int_t</span>
    <span class="pl-en">ngx_trylock_accept_mutex</span>(<span class="pl-c1">ngx_cycle_t</span> *cycle)
    {
    <span class="pl-c">//获取锁操作</span>
    <span class="pl-k">if</span> (<span class="pl-c1">ngx_shmtx_trylock</span>(&amp;ngx_accept_mutex)) {

        <span class="pl-c1">ngx_log_debug0</span>(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                       <span class="pl-s"><span class="pl-pds">"</span>accept mutex locked<span class="pl-pds">"</span></span>);
       <span class="pl-c">//获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁    </span>
        <span class="pl-k">if</span> (ngx_accept_mutex_held
            &amp;&amp; ngx_accept_events == <span class="pl-c1">0</span>
            &amp;&amp; !(ngx_event_flags &amp; NGX_USE_RTSIG_EVENT))
        {
            <span class="pl-k">return</span> NGX_OK;
        }
        <span class="pl-c">//获取到锁,则将所有监听事件添加到当前的epoll等事件驱动模块中  </span>
        <span class="pl-k">if</span> (<span class="pl-c1">ngx_enable_accept_events</span>(cycle) == NGX_ERROR) {
            <span class="pl-c1">ngx_shmtx_unlock</span>(&amp;ngx_accept_mutex);
            <span class="pl-k">return</span> NGX_ERROR;
        }

        ngx_accept_events = <span class="pl-c1">0</span>;
        ngx_accept_mutex_held = <span class="pl-c1">1</span>;

        <span class="pl-k">return</span> NGX_OK;
    }

    <span class="pl-c1">ngx_log_debug1</span>(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="pl-c1">log</span>, <span class="pl-c1">0</span>,
                   <span class="pl-s"><span class="pl-pds">"</span>accept mutex lock failed: <span class="pl-c1">%u</span>i<span class="pl-pds">"</span></span>, ngx_accept_mutex_held);
    <span class="pl-c">//表示此次没有获取到锁,但是上次获取到锁,此时会把当前work的epoll中删除监听的端口事件</span>
    <span class="pl-k">if</span> (ngx_accept_mutex_held) {
        <span class="pl-k">if</span> (<span class="pl-c1">ngx_disable_accept_events</span>(cycle) == NGX_ERROR) {
            <span class="pl-k">return</span> NGX_ERROR;
        }

        ngx_accept_mutex_held = <span class="pl-c1">0</span>;
    }

    <span class="pl-k">return</span> NGX_OK;
    }
</pre></div>

<h2>
<a id="有问题反馈" class="anchor" href="#%E6%9C%89%E9%97%AE%E9%A2%98%E5%8F%8D%E9%A6%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>有问题反馈</h2>

<p>在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流</p>

<ul>
<li>邮件(1031379296#qq.com, 把#换成@)</li>
<li>QQ: 1031379296</li>
<li>weibo: <a href="http://weibo.com/u/2786211992/home">@王发康</a>
</li>
</ul>

<h2>
<a id="关于作者" class="anchor" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于作者</h2>

<h3>
<a id="linuxnginxgolangcc爱好者" class="anchor" href="#linuxnginxgolangcc%E7%88%B1%E5%A5%BD%E8%80%85" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux\nginx\golang\c\c++爱好者</h3>

<h3>
<a id="欢迎一起交流--一起学习" class="anchor" href="#%E6%AC%A2%E8%BF%8E%E4%B8%80%E8%B5%B7%E4%BA%A4%E6%B5%81--%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>欢迎一起交流  一起学习</h3>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("nginx  惊群　　 thundering herd　");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
