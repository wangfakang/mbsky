{"name":"Mbsky","tagline":"nginx惊群","body":"``nginx惊群问题简单分析：\r\n``\r\n\r\n# 内容：\r\n\r\n## 一：惊群含义\r\n## 二：nginx如何解决惊群\r\n## 三：何时释放该锁\r\n## 四:相应代码解析\r\n\r\n\r\n\r\n\r\n### 一.惊群含义:\r\n    昨天所说的惊群含义是指:\r\n      当一个请求来到的时候,多个work进程的epoll注册监听端口都发生了可读事件,此时多个work进程都会去执行accept系统调用但最终只有一个work进程accept执行成功,造成了没有必要的上下文切换(这里的accept操作可以更深层次的\"唤醒\",此处\r\n    所说的\"唤醒\"不是说开始work进程都挂起的,然后把其唤醒,其实work进程几乎一直都是工作的如:处理一些之前已经建立好的一些网络事件).\r\n\r\n### 二.此时nginx解决惊群是这样的:\r\n        增加了一个\"accept_mutex\"锁,当其当前work进程抢到锁了才会去把监听端口的文件描述符加载到自己的epoll中,其他没有抢到锁的work进程会把之前所注册的相应端口的事件全部删除,此时会处理之前建立连接上的一些网络事件. 即\"在同一个时刻只会有一个work进程会在epoll中注册监听端口的描述符,每一个work进程都共享该监听端口描述符\".\r\n\r\n### 三.还有一个问题就是:\r\n      \"抢到的锁何时释放\",nginx是这样做的:使用了两个事件队列(ngx_posted_accept_events:可以理解存放新建连接的事件和ngx_posted_events:存放已经建立连接的事件),其实释放所的地方就是:当把新来的所有连接建立好三次握手了(此时把该事件放到ngx_posted_events)就会释放锁.\r\n       锁释放了此时在处理ngx_posted_events(已经完成了三次握手的事件)上的事件这样就可以让下次新的连接得到更快的处理,后面再来新的连接的时候继续按照前面的处理方式处理.\r\n\r\n### 四.代码解析\r\n \r\n ```\r\n\r\n    void\r\n    ngx_process_events_and_timers(ngx_cycle_t *cycle)\r\n    {\r\n    ngx_uint_t  flags;\r\n    ngx_msec_t  timer, delta;\r\n\r\n    if (ngx_timer_resolution) {\r\n        timer = NGX_TIMER_INFINITE;\r\n        flags = 0;\r\n\r\n    } else {\r\n        timer = ngx_event_find_timer();\r\n        flags = NGX_UPDATE_TIME;\r\n\r\n    #if (NGX_THREADS)\r\n\r\n        if (timer == NGX_TIMER_INFINITE || timer > 500) {\r\n            timer = 500;\r\n        }\r\n\r\n    #endif\r\n    }\r\n\r\n    if (ngx_use_accept_mutex) {\r\n        //表示当前进程的负载超过了最大连接数的7/8\r\n        if (ngx_accept_disabled > 0) {\r\n            ngx_accept_disabled--;\r\n\r\n        } else {\r\n            if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {\r\n                return;\r\n            }\r\n\r\n            if (ngx_accept_mutex_held) {\r\n                flags |= NGX_POST_EVENTS;\r\n\r\n            } else {// 不让其平凡的获取到锁   \r\n                if (timer == NGX_TIMER_INFINITE\r\n                    || timer > ngx_accept_mutex_delay)\r\n                {\r\n                    timer = ngx_accept_mutex_delay;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    delta = ngx_current_msec;\r\n\r\n    (void) ngx_process_events(cycle, timer, flags);\r\n\r\n    delta = ngx_current_msec - delta;\r\n\r\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\r\n                   \"timer delta: %M\", delta);\r\n    //处理新来的事件建立连接\r\n    if (ngx_posted_accept_events) {\r\n        ngx_event_process_posted(cycle, &ngx_posted_accept_events);\r\n    }\r\n    //处理完了就把其锁给释放了,让其新的连接可以被其尽快处理\r\n    if (ngx_accept_mutex_held) {\r\n        ngx_shmtx_unlock(&ngx_accept_mutex);\r\n    }\r\n\r\n    if (delta) {\r\n        ngx_event_expire_timers();\r\n    }\r\n\r\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\r\n                   \"posted events %p\", ngx_posted_events);\r\n    //锁释放了才处理已经建立好的事件(已经完成了三次握手的事件)\r\n    if (ngx_posted_events) {\r\n        if (ngx_threaded) {\r\n            ngx_wakeup_worker_thread(cycle);\r\n\r\n        } else {\r\n            ngx_event_process_posted(cycle, &ngx_posted_events);\r\n        }\r\n    }\r\n    }\r\n    \r\n    ```\r\n    \r\n    ```\r\n    ngx_int_t\r\n    ngx_trylock_accept_mutex(ngx_cycle_t *cycle)\r\n    {\r\n    //获取锁操作\r\n    if (ngx_shmtx_trylock(&ngx_accept_mutex)) {\r\n\r\n        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\r\n                       \"accept mutex locked\");\r\n       //获取到锁，但是标志位ngx_accept_mutex_held为1，表示当前进程已经获取到锁    \r\n        if (ngx_accept_mutex_held\r\n            && ngx_accept_events == 0\r\n            && !(ngx_event_flags & NGX_USE_RTSIG_EVENT))\r\n        {\r\n            return NGX_OK;\r\n        }\r\n        //获取到锁,则将所有监听事件添加到当前的epoll等事件驱动模块中  \r\n        if (ngx_enable_accept_events(cycle) == NGX_ERROR) {\r\n            ngx_shmtx_unlock(&ngx_accept_mutex);\r\n            return NGX_ERROR;\r\n        }\r\n\r\n        ngx_accept_events = 0;\r\n        ngx_accept_mutex_held = 1;\r\n\r\n        return NGX_OK;\r\n    }\r\n\r\n    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\r\n                   \"accept mutex lock failed: %ui\", ngx_accept_mutex_held);\r\n    //表示此次没有获取到锁,但是上次获取到锁,此时会把当前work的epoll中删除监听的端口事件\r\n    if (ngx_accept_mutex_held) {\r\n        if (ngx_disable_accept_events(cycle) == NGX_ERROR) {\r\n            return NGX_ERROR;\r\n        }\r\n\r\n        ngx_accept_mutex_held = 0;\r\n    }\r\n\r\n    return NGX_OK;\r\n    }\r\n```\r\n\r\n## 有问题反馈\r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\n## 关于作者\r\n\r\n### Linux\\nginx\\golang\\c\\c++爱好者\r\n### 欢迎一起交流  一起学习","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}